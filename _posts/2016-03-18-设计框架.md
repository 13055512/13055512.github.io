---
layout: post
title: 设计框架
tags: [MVC, MVP, MVVM]
categories: Android
---
# 设计框架 

## 测试
> 测试长长长长长长长长长长长长长长长长长长长长长长长
长长长长长长长长长长长引用`代码块`

> english Longgggggggggggggggggggggggggggggggggggg
[测试链接](http://guang2.github.io)

- 无序测试
    - 子无序
- 无序2

## 前言

### **Model：数据**
用于封装业务逻辑相关的数据以及对数据的处理方法。
本身是完全独立的个体，并且应该能被监听到执行的结果。M 层不应该知道 View 的存在。

最直接的例子就是网络请求，网络请求时完全独立于视图层的，而且做的事情也很单一，
可以很好地复用。

### Controller：控制层
用于连接 Model 层和 View 层。主要接收来自 View 的交互信号和 Model 的改变结果，
然后做相应的操作。

Adapter 应该属于这一层。因为 Adapter 中会做到很多数据的处理，比如根据数据类型选择 Item
这样的操作。而这样的操作如果放入 View 层，就会让 View 层一下子失去复用的能力。
控制层应该是最不容易复用的。

### **View：视图**
独立于数据，里面没有什么业务逻辑，仅仅是做展现。
Android 中的 View，比如 `TextView`，`Button` 等都属于此类。

至于 Activity、Fragment 算不算这层的东西呢？它们貌似都处于灰色地带，很难得到明确的定义。
相比传统的思路，其实可以认为 Activity 和 Fragment 是可以属于 V 层的。

## MVC
Model/View/Controller  
如果我们让 Activity 做 View 和 Model 的绑定操作，那么会让 Activity 越来越臃肿。
我们应该思考以下这些问题：

1. activity该做view的绑定工作么？
2. activity要做view的动画操作么？
3. activity应处理从网络返回的结果么？
4. activity需要做不同状态下view的状态的控制么？

## MVP
算是对 MVC 的一个升级，产生了清晰的分层。此时 Activity 和 XML 视为 View 层。  
View 操作 P 层，P 层会去调用 Model 执行操作，P 中接收到结果后去调用 V 层来更新界面。  
例子：

``` java
presenter = new AppInfoPresenter(); // p层
mShowPackageNameBtn.setOnClickListener(v -> {
    v.setEnabled(false); // activity变成v层，这里控制view的相关状态
    // 点击后的事情交给p做，p做完后应该给v一个回调。为了说明简单，这里是同步回调。
    string name = presenter.getPackageInfo(getApplication()); // p层将最终的结果交给v层
    mShowPackageNameBtn.setText(name); // 得到回调后更新视图
});
```

>内层对外层不知情的好处是内层可以随意地做复用，坏处就是需要建立相互通信的机制，会带来各种
回调。当然，你可以用 Rx 的方式很简单地做回调。
但当事件复杂后，就可以看出 MVP 中一个很蛋疼的后遗症————各种回调。而这些回调都是要根据不
同页面写的，而每写一个回调就要写一个接口，接口的参数也要根据需求变。
要是想弄得简单一点，第一种方式：可以让 P 和 V 层互相知道对方的存在。但这会造成 P 的复用性丧失。  
另一种方式：让 P 中包含 V 的对象，可以不用写任何回调就能直接触发 V 的方法。但如果这个 V
被复用，就要改一改了。这种方案的缺点是灵活性不够。  
MVP 的优点：

1. 当 Activity意外重启时 P 层不会被重启。
2. Activity 重启时， P 层和 Activity 会重新绑定，根据数据恢复 Activity 的状态。
3. 而当 Activity 真正的销毁时，对应的 P 层也会随之销毁。

## MVVM
可以算是 MVP 的升级版，即 Model/View/ViewModel，View 和 ViewModel 之间的交互通过 Data Binding 完成。  
*Model 层*：  
是很多具体类的聚合，主要做与展示无关的业务逻辑。要实现一个页面的需求，我们可能会用到很多
类，包括工具类和各种库。这些类都提供了一个或多个功能，我们利用这些功能便可最终实现需求。

*View 层*：  
具体的 View，Activity，Fragment 等，做 UI 展示/逻辑/动画。

*ViewModel 层*：  
由插件自动生成的具体类，是 View 展示的数据的 Java 抽象，仅能被 Model 层直接操作。


### 理想化的 MVVM 最好是只用写少量代码就能完成具体需求的东西。
以前的做法：  
建立 XML，在 Activity 中找到 View，创建数据模型，写好网络回调，回调成功后一次设置 View 的状态。  
理想化的做法：
写好数据模型，建立 XML 时直接绑定数据模型，在 Activity 中写好回调就行。
举个栗子：  
数据模型：

``` java
public class UserInfo extends BaseObservable {
    private String name;
    @Bindable
    public String getName() { return name; }
    public void setName(String name) {
        this.name = name;
        notifyPropertyChanged(com.kale.dream.BR.name);
    }
}
```

布局文件：

``` XML
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable name="user" type="com.kale.dream.UserInfo"/>
    </data>
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@{user.name}"
        />
</layout>
```

Activity：

```java
public class example extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final Dream01Binding binding = DataBindingUtil.setContentView(this, R.layout.dream_01);
        HttpUtil.doGet("http://www.xxxxxx", new HttpUtil.HttpCallback() {
            @Override
            public void onSuccess(UserInfo info) {
                binding.setUser(info);
            }
        });
    }
}
```

理想很丰满，现实很骨感。当我们需要处理的需求增加多时，Model 中的操作将变得越来越多，为了
解决这个问题，有些需求可以直接在 XML 中实现，当然并不是所有的需求都能在 XML 中实现，
比如动画，而且 XML 是有复用价值的。

### 现实的 MVVM
我们不希望一个框架对现有的项目结构做太多的影响，框架影响到用于 JSON 解析的 Model 是不能
容忍的。这样的话，我们需要建立一个给框架用的数据对象，所以 VM 现在就变成一个和前面的 JSON
的 Model 无关的独立类。需要注意的是：  
VM 仅仅处理和视图展现内容有关的逻辑，比如对显示的内容作格式化这样的事情。除此之外不应处理
其他的视图逻辑。  
数据模型：

```java
public class UserInfo {
    public String name;
}
```

ViewModel:

```java
public class DreamVm extends BaseObservable{
    private String name;
    @Bindable
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
        notifyPropertyChanged(com.kale.dream.BR.name);
    }
    @Bindable
    public int getViz() {
        switch (name) {
            case "jack":
                return View.VISIBLE;
            case "tony":
                return View.INVISIBLE;
            default:
                return View.GONE;
        }
    }

    /*
     *事务操作,这部分处理其实不应该放在这里
     */
    public void load() {
        HttpUtil.doGet("http://www.kalexxxxxx", new HttpUtil.HttpCallback<UserInfo02>() {
            @Override
            public void onSuccess(UserInfo02 info) {
                setName(info.name);
            }
        });
    }
}
```

布局文件：

```XML
// 将之前的userinfo换为vm来绑定
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@{vm.name}"
    android:visibility="@{vm.viz}"
    />
```

Activity：

``` java
public class DreamAct extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        final Dream02Binding binding = DataBindingUtil.setContentView(this, R.layout.dream_02);
        DreamVmp02 viewModel = new DreamVmp02();
        binding.setVm(viewModel);
        viewModel.load(); // 加载网络请求
    }
}
```

这么做就没什么大问题了，VM 处理了逻辑，Model 变成纯粹的类。而且也不用在布局文件中写什么
Java 代码了，只要绑定 VM 的字段就行了。View 相关的 Java 代码都在 Activity 中完成，如果
View 的逻辑出错了直接进入 Activity 中定位就好了。
